# NSDictionary的实现原理
### 字典是通过hash表来实现value和key之间的映射和存储的
##### 哈希表的本质是一个数组，数组中每个元素称为箱子，每个箱子中存放键值对
##### 哈希表的存储过程
1. 根据 key 计算出它的哈希值 h
2. 假设箱子的个数为 n，那么这个键值对应该放在第 (h % n) 个箱子中
3. 如果该箱子中已经有了键值对，就使用开放寻址法或者拉链法解决冲突

> 拉链法：将所有哈希地址相同的元素构成一个单链表
> 开放寻址法：这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中
> 再哈希法：同时构造多个不同的哈希函数

##### 负载因子
负载因子=总键值对/箱子个数（衡量哈希表的空/满程度）
负载因子越大，hash表越满，越容易导致冲突，性能越低
当负载因子大于某个数时，将自动扩容，键值对的位置也会发生改变，影响性能。这也叫重哈希
##### 常用哈希方法
1. 直接寻址法：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b
2. 随机数法：选择一随机函数，取关键字的随机值作为散列地址
3. 除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址

> hash函数的设计好坏影响字典的访问效率，数据在hash表中分布的越均匀，其访问效率就越高

### - (void)setObject:(id)anObject forKey:(id <NSCopying>)aKey; 

1. 作为 Key 值，必须遵循 NSCopying 协议。也就是说在NSDictionary内部，会对 aKey 对象 copy 一份新的。而  anObject 对象在其内部是作为强引用（retain或strong)
2. 在调用 setObject: forKey:  后，内部会去调用 key 对象的 hash 方法确定 object 在hash表内的入口位置，然后会调用 isEqual 来确定该值是否已经存在于 NSDictionary中

### - (NSUInteger)hash
key值必须重载的方法，hash方法是用来计算该对象的hash值，最终hash值决定了该对象在 hash 表中存储的位置，要想字典的访问效率高，必须尽量设计一个能让数据均匀分布的hash函数

### - (BOOL)isEqual:(id)object
通过 hash 值来找到 对象 在hash 表中的位置


