# 解释一下多线程中的死锁？
死锁是由于多个线程（进程）在执行过程中，因为争夺资源而造成的互相等待现象，你可以理解为卡主了。产生死锁的必要条件有四个：

* 互斥条件 ： 指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
* 请求和保持条件 ： 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
* 可剥夺条件 ： 指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
* 环路等待条件 ： 指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。
最常见的死锁

```
- (void)viewDidLoad {
    [super viewDidLoad];
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@"1");
    });
    NSLog(@"2");
    }
```
同步执行+主队列，以上什么都不会打印。viewDidLoad是在主队列执行，Block里面NSLog(@"1")也是在主队列。由于是同步执行，一次只能执行一个任务，主队列是串行队列，要按顺序执行。viewDidLoad优先进入主队列。Block里面NSLog(@"1")排在后面。那么Block里面NSLog(@"1")要等viewDidLoad执行完才会执行。而viewDidLoad要执行完又要先执行Block里面NSLog(@"1")。这样就形成了循环等待造成死锁。

